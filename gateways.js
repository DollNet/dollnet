// Generated by CoffeeScript 1.7.1
(function() {
  var areas, cache, dns, do_test, domain, gateways, geoip, http, https, id, lists, mmdbreader, net, result, schemas, shttp, shttps, socks, test, testcases, type, uri, url;

  dns = require('dns');

  domain = require('domain');

  url = require('url');

  net = require('net');

  http = require('http');

  https = require('https');

  socks = require('socks5-client');

  shttp = require('socks5-http-client');

  shttps = require('socks5-https-client');

  mmdbreader = require('maxmind-db-reader');

  geoip = mmdbreader.openSync('./GeoLite2-Country.mmdb');

  schemas = {
    ss: require('./protocols/shadowsocks')
  };

  testcases = {
    continent: {
      NA: "http://twitter.com/",
      EU: "http://www.bbc.co.uk/"
    },
    country: {
      CN: "http://www.163.com/",
      JP: "http://www.baidu.jp/"
    },
    list: {
      google: "http://plus.google.com/"
    }
  };

  lists = {
    google: require('./google_domains.json')
  };

  gateways = (function() {
    var _ref, _results;
    _ref = require('./gateways.json');
    _results = [];
    for (id in _ref) {
      uri = _ref[id];
      result = {
        id: id,
        uri: uri,
        latency: {
          destination: {}
        }
      };
      for (type in testcases) {
        areas = testcases[type];
        result.latency[type] = {};
      }
      _results.push(result);
    }
    return _results;
  })();

  cache = {};

  do_test = {
    direct: function(gateway, type, area, testcase, callback) {
      var client, req, testcase_uri;
      testcase_uri = url.parse(testcase);
      switch (testcase_uri.protocol.split(':')[0]) {
        case 'http':
        case 'https':
          req = (testcase_uri.protocol.split(':')[0] === 'http' ? http : https).request({
            hostname: testcase_uri.hostname,
            port: testcase_uri.port,
            path: testcase_uri.path,
            method: 'HEAD'
          }, function(res) {
            return callback();
          });
          req.end();
          return req.on('error', function(err) {
            return callback(err);
          });
        case 'tcp':
          client = net.connect(testcase_uri.port, testcase_uri.hostname, function() {
            client.end();
            return callback();
          });
          return client.on('error', function(err) {
            return callback(err);
          });
      }
    },
    http: function(gateway, type, area, testcase, callback) {
      var gateway_uri, req, testcase_uri, _ref;
      testcase_uri = url.parse(testcase);
      gateway_uri = url.parse((_ref = gateway.service) != null ? _ref : gateway.uri);
      switch (testcase_uri.protocol.split(':')[0]) {
        case 'http':
          req = http.request({
            hostname: gateway_uri.hostname,
            port: gateway_uri.port,
            path: testcase,
            method: 'HEAD'
          }, function(res) {
            return callback();
          });
          req.end();
          return req.on('error', function(err) {
            return callback(err);
          });
        case 'https':
        case 'tcp':
          throw 'https/tcp test over http is not supported now';
      }
    },
    socks5: function(gateway, type, area, testcase, callback) {
      var client, d, gateway_uri, testcase_uri, _ref;
      testcase_uri = url.parse(testcase);
      gateway_uri = url.parse((_ref = gateway.service) != null ? _ref : gateway.uri);
      switch (testcase_uri.protocol.split(':')[0]) {
        case 'http':
        case 'https':
          d = domain.create();
          d.on('error', function(err) {
            return callback(err);
          });
          return d.run(function() {
            var req;
            req = (testcase_uri.protocol.split(':')[0] === 'http' ? shttp : shttps).request({
              hostname: testcase_uri.hostname,
              port: testcase_uri.port,
              path: testcase_uri.path,
              method: 'HEAD',
              socksHost: gateway_uri.hostname,
              socksPort: gateway_uri.port
            }, function(res) {
              return callback();
            });
            req.end();
            return req.on('error', function(err) {
              return callback(err);
            });
          });
        case 'tcp':
          client = socks.createConnection({
            host: testcase_uri.hostname,
            port: testcase_uri.port,
            socksHost: gateway_uri.hostname,
            socksPort: gateway_uri.port
          });
          client.on('connect', function() {
            client.end();
            return callback();
          });
          return client.on('error', function(err) {
            return callback(err);
          });
      }
    }
  };

  test = function(gateway, log) {
    var gateway_uri, schema, started_at;
    started_at = new Date();
    gateway_uri = url.parse(gateway.uri);
    schema = gateway_uri.protocol.split(':')[0];
    return Object.keys(testcases).forEach(function(type) {
      return Object.keys(testcases[type]).forEach(function(area) {
        var service_protocol, testcase, _ref;
        testcase = testcases[type][area];
        uri = url.parse((_ref = gateway.service) != null ? _ref : gateway.uri);
        service_protocol = uri.protocol.split(':')[0];
        return do_test[service_protocol](gateway, type, area, testcase, function(err) {
          if (err) {
            gateway.latency[type][area] = false;
            return log.warn('speedtest', {
              type: type,
              area: area,
              error: err.toString()
            });
          } else {
            gateway.latency[type][area] = new Date() - started_at;
            return log.info('speedtest', {
              type: type,
              area: area,
              latency: gateway.latency[type][area]
            });
          }
        });
      });
    });
  };

  module.exports = {
    select: function(destination, callback) {
      var best_gateway, best_gateway_latency, gateway, latency, _i, _len;
      best_gateway = null;
      best_gateway_latency = null;
      for (_i = 0, _len = gateways.length; _i < _len; _i++) {
        gateway = gateways[_i];
        latency = gateway.latency.destination[destination];
        if (latency && (!best_gateway || latency < best_gateway_latency)) {
          best_gateway_latency = latency;
          best_gateway = gateway;
        }
      }
      if (best_gateway) {
        return callback(best_gateway);
      } else {
        return this.detect(destination, function(err, type, area) {
          var _j, _k, _len1, _len2;
          if (!err) {
            for (_j = 0, _len1 = gateways.length; _j < _len1; _j++) {
              gateway = gateways[_j];
              latency = gateway.latency[type][area];
              if (latency && (!best_gateway || latency < best_gateway_latency)) {
                best_gateway_latency = latency;
                best_gateway = gateway;
              }
            }
          }
          if (best_gateway) {
            return callback(best_gateway);
          } else {
            for (_k = 0, _len2 = gateways.length; _k < _len2; _k++) {
              gateway = gateways[_k];
              latency = gateway.latency['list']['google'];
              if (latency && (!best_gateway || latency < best_gateway_latency)) {
                best_gateway_latency = latency;
                best_gateway = gateway;
              }
            }
            if (best_gateway) {
              return callback(best_gateway);
            } else {
              return gateways[0];
            }
          }
        });
      }
    },
    detect: function(destination, callback) {
      var area, c, pattern, regexp, site, sites, _i, _len;
      if (c = cache[destination]) {
        return callback(null, c[0], c[1]);
      } else {
        for (area in lists) {
          sites = lists[area];
          for (_i = 0, _len = sites.length; _i < _len; _i++) {
            site = sites[_i];
            pattern = site.replace('^\.', '(.+\.)?');
            regexp = new RegExp(pattern, 'i');
            if (regexp.test(destination)) {
              cache[destination] = ['list', area];
              return callback(null, 'list', area);
            }
          }
        }
        if (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(destination)) {
          return geoip.getGeoData(destination, function(err, geodata) {
            var country, _ref;
            if (err) {
              return callback(err);
            }
            if (!geodata) {
              return callback(true);
            }
            country = (_ref = geodata.country) != null ? _ref : geodata.registered_country;
            if (country && testcases.country[country.iso_code]) {
              cache[destination] = ['country', country.iso_code];
              return callback(null, 'country', country.iso_code);
            } else if (testcases.continent[geodata.continent.code]) {
              cache[destination] = ['continent', geodata.continent.code];
              return callback(null, 'continent', geodata.continent.code);
            } else {
              return callback(true);
            }
          });
        } else {
          return dns.lookup(destination, (function(_this) {
            return function(err, address, family) {
              if (err) {
                return callback(err);
              }
              if (!address) {
                return callback(true);
              }
              return _this.detect(address, function(err, type, area) {
                if (!err) {
                  cache[destination] = [type, area];
                }
                return callback(err, type, area);
              });
            };
          })(this));
        }
      }
    },
    start: function(log) {
      return gateways.forEach(function(gateway) {
        var gateway_uri, schema, _log;
        _log = log.child({
          gateway: gateway.id
        });
        gateway_uri = url.parse(gateway.uri);
        schema = gateway_uri.protocol.split(':')[0];
        switch (schema) {
          case 'direct':
          case 'http':
          case 'https':
            return test(gateway, _log);
          default:
            if (!schemas[schema]) {
              throw "unknown protocol " + gateway.uri;
            }
            return schemas[schema].start(gateway.uri, function(service) {
              gateway.service = service;
              return test(gateway, _log);
            });
        }
      });
    }
  };

}).call(this);

//# sourceMappingURL=gateways.map
