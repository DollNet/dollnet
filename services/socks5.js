// Generated by CoffeeScript 1.7.1
(function() {
  var AddressTypes, AuthMethods, CommandType, States, dns, domain, http, net, url, _;

  net = require('net');

  url = require('url');

  dns = require('dns');

  http = require('http');

  domain = require('domain');

  _ = require('underscore');

  States = {
    CONNECTED: 0,
    VERIFYING: 1,
    READY: 2,
    PROXY: 3
  };

  AuthMethods = {
    NOAUTH: 0,
    GSSAPI: 1,
    USERPASS: 2
  };

  CommandType = {
    TCPConnect: 1,
    TCPBind: 2,
    UDPBind: 3
  };

  AddressTypes = {
    IPv4: 0x01,
    DomainName: 0x03,
    IPv6: 0x04
  };

  module.exports = {
    start: function(log, gateways) {
      log = log.child({
        service: 'socks5'
      });
      return net.createServer(function(connection) {
        var id;
        id = _.uniqueId();
        log.debug('session', {
          id: id,
          state: 'CONNECTED',
          from: "" + connection.remoteAddress + ":" + connection.remotePort
        });
        connection.state = States.CONNECTED;
        connection.on("data", function(chunk) {
          var address, i, offset, port, resp, _i, _ref;
          switch (connection.state) {
            case States.CONNECTED:
              if (chunk[0] !== 5) {
                log.error('session', {
                  id: id,
                  error: 'unknown protocol'
                });
                connection.end();
              }
              connection.methods = [];
              for (i = _i = 0, _ref = chunk[1]; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                connection.methods.push(chunk[2 + i]);
                i++;
              }
              resp = new Buffer(2);
              resp[0] = 0x05;
              if (connection.methods.indexOf(AuthMethods.NOAUTH) !== -1) {
                log.debug('session', {
                  id: id,
                  state: 'READY'
                });
                connection.state = States.READY;
                resp[1] = AuthMethods.NOAUTH;
                return connection.write(resp);
              } else {
                log.debug('session', {
                  id: id,
                  error: 'client don\'t support anonymous authentication'
                });
                resp[1] = 0xFF;
                return connection.end(resp);
              }
              break;
            case States.READY:
              if (chunk[0] !== 5) {
                log.error('session', {
                  id: id,
                  error: 'unknown protocol'
                });
                chunk[1] = 0x01;
                return connection.end(chunk);
              }
              offset = 3;
              switch (chunk[offset]) {
                case AddressTypes.IPv4:
                  address = chunk[offset + 1] + "." + chunk[offset + 2] + "." + chunk[offset + 3] + "." + chunk[offset + 4];
                  offset += 4 + 1;
                  break;
                case AddressTypes.DomainName:
                  address = chunk.toString("utf8", offset + 2, offset + 2 + chunk[offset + 1]);
                  offset += chunk[offset + 1] + 1 + 1;
                  break;
                case AddressTypes.IPv6:
                  address = chunk.slice(chunk[offset + 1], chunk[offset + 1 + 16]);
                  offset += 16 + 1;
              }
              port = chunk.readUInt16BE(offset);
              return gateways.select(address, function(gateway) {
                var client, req, uri, _ref1;
                uri = url.parse((_ref1 = gateway.service) != null ? _ref1 : gateway.uri);
                switch (uri.protocol.split(':')[0]) {
                  case 'socks5':
                    client = net.connect(uri.port, uri.hostname, function() {
                      client.write(new Buffer([5, 1, 0]));
                      return client.state = States.CONNECTED;
                    });
                    client.on('data', function(d) {
                      switch (client.state) {
                        case States.CONNECTED:
                          if (!(d[0] === 5 && d[1] === 0)) {
                            throw '3';
                          }
                          log.info('session', {
                            id: id,
                            state: 'PROXY',
                            destination: "" + address + ":" + port,
                            gateway: gateway.id
                          });
                          connection.state = States.PROXY;
                          client.state = States.PROXY;
                          client.write(chunk);
                          client.pipe(connection);
                          return connection.pipe(client);
                      }
                    });
                    return client.on('error', function(err) {
                      log.warn('session', {
                        id: id,
                        error: err
                      });
                      if (connection.state === States.READY) {
                        resp = new Buffer([5, 1, 0, 1, 0, 0, 0, 0, 0, 0]);
                        return connection.end(resp);
                      } else {
                        return connection.end();
                      }
                    });
                  case 'direct':
                    switch (chunk[1]) {
                      case CommandType.TCPConnect:
                        client = net.connect(port, address, function() {
                          var index, value, _ref2;
                          log.info('session', {
                            id: id,
                            state: 'PROXY',
                            destination: "" + address + ":" + port,
                            gateway: gateway.id
                          });
                          connection.state = States.PROXY;
                          resp = new Buffer([5, 0, 0, 1, 0, 0, 0, 0, 0, 0]);
                          _ref2 = client.address().address.split('.');
                          for (index in _ref2) {
                            value = _ref2[index];
                            resp[4 + index] = parseInt(value);
                          }
                          resp.writeUInt16BE(client.address().port, 8);
                          connection.write(resp);
                          connection.pipe(client);
                          client.pipe(connection);
                          client.on('end', function(had_error) {
                            return connection.end();
                          });
                          return connection.on('end', function(had_error) {
                            return client.end();
                          });
                        });
                        return client.on('error', function(err) {
                          log.warn('session', {
                            id: id,
                            error: err
                          });
                          if (connection.state === States.READY) {
                            resp = new Buffer([5, 1, 0, 1, 0, 0, 0, 0, 0, 0]);
                            return connection.end(resp);
                          } else {
                            return connection.end();
                          }
                        });
                      default:
                        throw "only tcp connect supported";
                        return connection.end(chunk);
                    }
                    break;
                  case 'http':
                    switch (chunk[1]) {
                      case CommandType.TCPConnect:
                        req = http.request({
                          hostname: uri.hostname,
                          port: uri.port,
                          path: "" + address + ":" + port,
                          method: 'CONNECT'
                        });
                        req.end();
                        req.on('connect', function(res, client, head) {
                          var index, value, _ref2;
                          if (res.statusCode === 200) {
                            log.info('session', {
                              id: id,
                              state: 'PROXY',
                              destination: "" + address + ":" + port,
                              gateway: gateway.id
                            });
                            connection.state = States.PROXY;
                            resp = new Buffer([5, 0, 0, 1, 0, 0, 0, 0, 0, 0]);
                            _ref2 = client.address().address.split('.');
                            for (index in _ref2) {
                              value = _ref2[index];
                              resp[4 + index] = parseInt(value);
                            }
                            resp.writeUInt16BE(client.address().port, 8);
                            connection.write(resp);
                            connection.pipe(client);
                            client.pipe(connection);
                            client.on('error', function(err) {
                              return log.warn('session', {
                                id: id,
                                error: err
                              });
                            });
                            client.on('end', function(had_error) {
                              return connection.end();
                            });
                            return connection.on('end', function(had_error) {
                              return client.end();
                            });
                          } else {
                            log.warn('session', {
                              id: id,
                              error: res.statusCode
                            });
                            resp = new Buffer([5, 1, 0, 1, 0, 0, 0, 0, 0, 0]);
                            connection.end(resp);
                            return client.end();
                          }
                        });
                        return req.on('error', function(err) {
                          log.warn('session', {
                            id: id,
                            error: err
                          });
                          if (connection.state === States.READY) {
                            resp = new Buffer([5, 1, 0, 1, 0, 0, 0, 0, 0, 0]);
                            return connection.end(resp);
                          } else {
                            return connection.end();
                          }
                        });
                      default:
                        throw "only tcp connect supported";
                        return connection.end(chunk);
                    }
                    break;
                  default:
                    throw "unknown protocol for " + gateway.uri;
                }
              });
          }
        });
        return connection.on('error', function(err) {
          return log.warn('session', {
            id: id,
            error: err
          });
        });
      }).listen(1080, function() {
        return log.info('started');
      });
    }
  };

}).call(this);

//# sourceMappingURL=socks5.map
